# HTTP 통신

**H**yper **T**ext **T**ransfer **P**rotocol
**HTML문서를 교환**하기 위해 만들어진 프로토콜(=protocol, 통신규약)

**프론트엔드와 백엔드간의 통신에서도 사용**

#### Connectionless

서버에 요청을 보내면 서버는 응답을 하고 접속을 끊는 특성 (**비 연결지향**)
 (HTTP1.1에서 `Connection` 헤더에 `keep-alive`라고 설정하면 연결을 유지할 수 있음)

#### Stateless

요청을 응답하고 접속을 끊기 때문에 상태 정보를 알 수 없음 ( **상태를 저장하지 않음** )
= 요청이 오면 응답, 여러 요청과 응답끼리 연결되어 있지 않음 (전에 요청과 응답에 대해 알 수 없음)
→ **각각의 요청과 응답은 독립적인 요청과 응답**

>  여러 요청과 응답의 데이터가 필요하면 **쿠키와 세션**등을 사용



## fetch

http는 요청과 응답이 한 세트인데, **fetch함수를 이용**할 수 있음

**fetch는 프론트엔드에서 서버로 보내는 함수**
fetch안에는 보낼 것들을 넣어서 보내는데 get, post, url(주소) 등등임
`url = http프로토콜+도메인주소(또는 ip주소)+포트(도메인의경우 기본설정되면 생략될 수도)+엔드포인트`

header와 body로 나누어져 있음

요청을 하면 응답을 받는데 그 응답을 받을 때 쓰는 메서드가 `.then()`
**then**은 promise함수이고, 무엇보다 함수이므로 인자가 들어갈 수 있음

> promise는 자바스크립트 비동기 처리에 사용되는 객체
> 비동기 처리는 '특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행'

```javascript
fetch("http://10.58.1.192:8000/comment")
    .then((response) => response.json()) //여기서 then은 fetch에 대한 then임
    .then((res) => this.setState({data:res}, () => console.log(this.state)))
// 여기서 .then((res) => )에서의 (res)는 화살표함수의 앞 ()임

// 여기서 then은 json()에 대한 then임

// 하지만 로그인 할때는 token
.then((res) => localStorage.setItem("token", res.token))
```



## get, post

- **get**
  **서버로부터 정보를 조회**하기 위해 설계된 메서드

  요청을 전송할 때 필요한 데이터를 Body에 담지 않고, **쿼리스트링을 통해 전송**
  (URL에 데이터를 붙여서 전송)

  > 쿼리스트링은 url 끝에 함께 이름과 값으로 쌍을 이루는 요청 파라미터

  만약 요청 파라미터가 여러 개이면 &로 연결
  쿼리스트링을 사용하게 되면 특정 페이지를 링크하거나 북마크할 수 있음

- **post**
  **리소스를 생성, 변경**하기 위해 설계

  GET과 달리 전송해야될 데이터를 HTTP 메세지의 **Body에 담아서 전송**
  (body는 길이 제한이 없어 post요청은 get과 달리 **대용량 데이터를 전송 가능**)

서버와의 응답시 서버와 클라이언트가 서로 다른 형식만을 추구하면 데이터 전달이 안될 수 있음



## JSON.stringify

자바스크립트의 값을 **JSON 문자열로 변환**하는 메소드
Header부분은 json화 하지 않아도 서버에서 해석 가능
but **Body의 데이터부분은 JSON.stringify를 하여 서버로 전송**해야 서버에서 전달받기 가능