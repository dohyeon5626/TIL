# 클린코드\_3장_함수

어떤 프로그램이든 가장 기본적인 단위가 함수
이 장은 함수를 잘 만드는 법을 소개함

### 작게 만들어라!

**함수는 중첩 구조가 생길만큼 커지면 안됨**
중첩 구조가 생길수록, 코드는 길어지고, 코드의 재활용은 적어짐

> 함수에서는 들여쓰기  수준이 1단 2단을 넘어설 정도의 코드를 짜면 안됨

### 한 가지만 해라!

```
"함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한가지만을 해야한다."
```

> 사람마다 보는 관점에 따라, 여러 기능을 한다고 생각할 수 있음
> 하지만, 함수의 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다고 할 수 있음

### 함수 당 추상화 수준은 하나로!

**추상화의 수준은 힘들지 몰라도, 하나로 하는 것이 좋음**
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈림

> 추상화 수준을 섞게 된다면, 특정 표현이 근본 개념인지 아니면 세부 사항인지 구분하기 어렵게 됨

---

#### 내려가기 규칙

```
"코드는 위에서 아래로 이야기처럼 읽혀야 좋다"
```

**위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아짐** (내려가기 규칙)

### Switch 문

장황한 switch 문의 반복은 추상 팩토리 & 다형성 객체 생성 코드로 개선할 수 있음

### 서술적인 이름을 사용하라!

```
"코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다"
```

이름이 길어도 괜찮음, 길고 서술적인 이름이 짧고 어려운 이름보다 좋음

> 길고 서술적인 이름이 길고 서술적인 주석보다 좋음

이름을 붙일 때는 일관성이 있어야 함
문체가 비슷하면 이야기를 이야기를 순차적으로 풀어가기도 쉬워짐

### 함수 인수

함수에서 이상적인 인수 개수는 0개, 다음은 1개, 그 다음은 2개임
3개는 가능한 피하는 편이 좋고, 4개 이상은 특별한 이유가 필요함

인수는 개념을 이해하기 어렵게 만듦

> 플래그 인수는 매우 추함
> 함수로 Boolean 값을 넘기는 관례는 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이므로 정말로 끔찍함

좋은 함수 이름이 매우 중요함
단항함수에 경우에는 함수 이름과 인수 이름이 동사/명사 쌍을 이루어야 함

### 부수 효과를 일으키지 마라!

함수에서는 한 가지만을 해야함
떄로는 부수효과를 원하게 된다면, 중간에 예상치 못하게 클래스 변수를 수정하거나
또는 함수로 넘어온 인수나 시스템 전역 변수를 수정하게 될 수도 있음
어느 쪽이든 많은 경우 시간적인 결합이나 순서 종속성을 초래함

---

예를 한번 들어보겠음

```java
public class UserValidator {
    private Cyptographer cyptographer;
    
    public boolean checkPassword(String userName, String password) {
        User user = UserGateway.findByName(userName);
        if(user != User.NULL) {
            String codedPhrase = user.getPhraseEncodedByPassword();
            String phrase = cyptographer.decrypt(codedPhrase, password);
            if("Valid Password".equals(phrase)) {
                Session.initialize(); // 세션 초기화라는 부수효과를 일으킴
                return true;
            }
            return false;
        }
    }
}
```

위와 같은 예시도 부수효과를 일으키는 안 좋은 예임
위 `checkpassword()`는 세션을 초기화해도 괜찮은 경우에만 호출이 가능함, 하지만 초기화하면 안되는 경우에 모르고 호출을 하여 문제를 일으킬 가능성이 있음

### 명령과 조회를 분리하라!

함수는 한가지만 해야함
그러므로 명령과 조회를 한 함수에 넣는 것은 매우 안 좋은 일임

무엇보다 명령과 조회를 한번에 하면, 개발자에게 혼란을 주는 일임

### 오류 코드보다 예외를 사용하라!

명령 함수에서 오류 코드를 변환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반함

오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힘
반면 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해짐

---

##### Try/Catch 블록 뽑아내기

try/catch 블록은 원래 추하다. 블록을 별도 함수로 뽑아내는 편이 좋음

---

##### 오류 처리도 한 가지 작업이다

함수는 한가지 작업만 해야함
오류 처리도 한 가지 작업에 속하므로 오류를 처리하는 함수는 오류만 처리해야 마땅함

---

##### Error.java 의존성 자석(magnet)

오류 코드를 반환한다는 이야기는 클래스든 Enum이든 오류 코드를 정의한다는 뜻인데, Error Enum이 변한다면 Enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 함

하지만 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생됨
재컴파일/재파일 없이도 새 예외 클래스를 추가할 수 있음

### 반복하지 마라!

중복은 문제임
코드가 늘어나게 되고, 한 부분을 수정하게 된다면 모든 부분을 수정해야 하므로 수정하는 과정에서 빠뜨려서 오류를 발생할 가능성이 생기기도 함

그러므로 중복은 최대한 제거하고, 반복하지 않는 노력을 해야함

### 구조적 프로그래밍

```데이크스트
"함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다"
```

함수는 return문이 하나여야 한다는 말
**루프 안에서 break나 continue를 사용해선 안 되며 goto는 절대로 안됨**

하지만 위 규칙은 함수가 작다면 별 이익을 제공하지 못함
**함수가 아주 클 때만 상당한 이익을 제공함**

그러므로 **함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮음**
오히려 떄로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워짐

반면 goto 문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해가야함