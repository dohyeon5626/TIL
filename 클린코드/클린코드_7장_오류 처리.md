# 클린코드\_7장_오류 처리

깨끗한 코드와 오류 처리는 확실히 연관성이 있음

여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기 거의 불가능함
-> **오류 처리가 중요함**

### 오류 코드보다 예외를 사용하라

예외를 사용하게 된다면, 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리할 수 있으므로, 각 개념을 독립적으로 살펴보고 이해할 수 있음

> 예외를 사용하면 예외가 시작하자마자, 프로그램이 바로 멈추기 때문에 매우 편리함
> -> 오류를 찾아서 종료까지 코드를 짤 필요가 없음

### Try-Catch-Finally 문부터 작성하라

`try`블록에서 실행이 중단된 후 `catch`문으로 바로 넘어감

> 어떤 면에선 `try`블록은 트랜잭션과 비슷함

`try`블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워짐

> `try`블록에서 무슨 일이 생기든지 `catch`블록은 프로그램 상태를 일관성 있게 유지해야 함

---

`try-catch` 구조로 범위를 정의했으면, TDD를 사용해 필요한 나머지 논리를 추가함

> TDD : 테스트 주도 개발

먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장함
그러면, 자연스럽게 `try`블록의 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워짐

### 미확인 예외를 사용하라

확인된 예외는 컴파일 단계에서 확인되며 반드시 처리해야 할 예외

> 일반 예외

미확인된 예외는 실행 단계에서 확인되며 명시적인 처리를 강제하지 않는 예외

> 실행 예외
>
> > - NullPointerException
> > - IllegalArgumentException
> > - IndexOutOfBoundException
> > - SystemException

지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지 않다는 사실이 분명해짐, C#, C++은 확인된 예외를 지원하지 않음
하지만, 그럼에도 C#, C++은 안정적인 소프트웨어를 만드는데 불편함이 없음

> 확인된 예외는 OCP를 위반함
>
> > OCP : 개방-폐쇄 원칙
> >
> > ```
> > '소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다'
> > ```

### 예외에 의미를 제공하라

오류가 발생한 원인과 위치를 찾기 쉽도록 정보를 충분히 덧불여야 함

> 호출 스택만으로는 부족!

ex) 실패한 연산 이름, 실패 유형...

### 호출자를 고려해 예외 클래스를 정의하라

오류를 잡아내는 방법은 수없이 많고, 오류를 정의할 때 고려해야 할 중요한 사항

```java
 try {
     port.open();
 } catch (DeviceResponseException e) {
     reportPortError(e);
     logger.log("Device response exception", e);
 } catch (ATM1212UnlockedException e) {
     reportPortError(e);
     logger.log("Unlock exception", e);
 } catch (GMXError e) {
     reportPortError(e);
     logger.log("Device response exception");
 } finally {
     ...
 }
```

위 코드를 보면 모든 예외를 호출자가 잡아내서 예외를 던짐

위 코드를 아래와 같이 할 수도 있음

```java
 LocalPort port = new LocalPort(12);
 try {
     port.open();
 } catch (PortDeviceFailure e) {
     reportError(e);
     logger.log(e.getMessage(), e);
 } finally {
     ...
 }
```

위 코드는 외부 API를 `try-catch`문으로 감싸고 있는데, 이러면 예외 유형 하나를 반환하게 됨
이렇게 하면 에러 처리가 간편하고, 외부 라이브러리와 프로그램 사이의 의존성이 줄고, 프로그램 테스트가 쉬우며, 외부 API 설계 방식에 의존하지 않아도 되는 장점이 생김

이렇게 어떻게 예외처리를 하느냐에 따라 달라지게 되므로, 호출자를 고려해서 예외처리를 해야함

### 정상 흐름을 정의하라

`Special Case Pattern` 특수 사례 패턴

클래스를 만들거나 객체를 이용해 특수 사례를 캡슐화하여 예외처리함

>  특수 사례 패턴을 이용하면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어짐

---

비즈니스 논리와 오류 처리가 잘 분리된 코드는 간결한 알고리즘으로 보일 수 있으나 오류 감지가 프로그램 언저리로 밀려날 우려가 있음

그래서 특수 사례 패턴을 이용해 예외처리하는 방법이 있음

### null을 반환하지 마라

null을 반환하게 되면, 반환 값을 받는 쪽에서 null을 체크하는 코드를 계속 만들어야 하기 때문에, 코드의 중복이 늘어나고, 실수하기 쉬움

null 대신 예외를 던지거나 특수 사례 객체를 반환하는 방식을 추천함

> ex) Collections.emptyList()

### null을 전달하지 마라

함수로 null을 반환하는 것처럼 함수 인수로 null을 전달하는 방식은 안 좋음

방금 위처럼, null을 체크하는 코드를 계속 만들어야 하기 때문에, 코드의 중복이 늘어나고, 실수하기 쉬움

### 결론

깨끗한 코드(클린코드)는 읽기 좋아야 하기도 하지만, 안정성도 높아야함
이 둘은 서로 상충하는 목표가 아니기에, 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있음

> 독립적인 추론이 가능해지고, 코드 유지보수성도 크게 높아짐